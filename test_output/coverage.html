
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">labours-go/cmd/helpers.go (0.0%)</option>
				
				<option value="file1">labours-go/cmd/modes.go (0.0%)</option>
				
				<option value="file2">labours-go/cmd/root.go (0.0%)</option>
				
				<option value="file3">labours-go/internal/graphics/heatmap.go (0.0%)</option>
				
				<option value="file4">labours-go/internal/graphics/stacked-plot.go (0.0%)</option>
				
				<option value="file5">labours-go/internal/modes/burndown.go (80.0%)</option>
				
				<option value="file6">labours-go/internal/modes/burndownFile.go (0.0%)</option>
				
				<option value="file7">labours-go/internal/modes/burndownPerson.go (0.0%)</option>
				
				<option value="file8">labours-go/internal/modes/burndownProject.go (0.0%)</option>
				
				<option value="file9">labours-go/internal/modes/devs.go (0.0%)</option>
				
				<option value="file10">labours-go/internal/modes/overwrites.go (0.0%)</option>
				
				<option value="file11">labours-go/internal/modes/ownership.go (0.0%)</option>
				
				<option value="file12">labours-go/internal/pb/pb.pb.go (0.0%)</option>
				
				<option value="file13">labours-go/internal/readers/helpers.go (0.0%)</option>
				
				<option value="file14">labours-go/internal/readers/pb_reader.go (48.3%)</option>
				
				<option value="file15">labours-go/internal/readers/yaml_reader.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cmd

import (
        "fmt"
        "labours-go/internal/readers"
        "os"
        "time"

        "github.com/araddon/dateparse"
        "github.com/spf13/viper"
)

// parseFlexibleDate parses a date string into a time.Time object.
// Returns an error if the date cannot be parsed.
func parseFlexibleDate(dateStr string) (time.Time, error) <span class="cov0" title="0">{
        parsedDate, err := dateparse.ParseAny(dateStr)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("invalid date format: %v", err)
        }</span>
        <span class="cov0" title="0">return parsedDate, nil</span>
}

func contains(slice []string, value string) bool <span class="cov0" title="0">{
        for _, item := range slice </span><span class="cov0" title="0">{
                if item == value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func parseDates() (startTime *time.Time, endTime *time.Time) <span class="cov0" title="0">{
        if startTimeStr := viper.GetString("start-date"); startTimeStr != "" </span><span class="cov0" title="0">{
                parsedStartTime, err := parseFlexibleDate(startTimeStr)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error parsing start date: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">startTime = &amp;parsedStartTime</span>
        }

        <span class="cov0" title="0">if endTimeStr := viper.GetString("end-date"); endTimeStr != "" </span><span class="cov0" title="0">{
                parsedEndTime, err := parseFlexibleDate(endTimeStr)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Error parsing end date: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">endTime = &amp;parsedEndTime</span>
        }

        <span class="cov0" title="0">return startTime, endTime</span>
}

func validateDateRange(startTime, endTime *time.Time) <span class="cov0" title="0">{
        if startTime != nil &amp;&amp; endTime != nil &amp;&amp; endTime.Before(*startTime) </span><span class="cov0" title="0">{
                fmt.Println("Error: end date must be after start date")
                os.Exit(1)
        }</span>
}

func detectAndReadInput(input, inputFormat string) readers.Reader <span class="cov0" title="0">{
        reader, err := readers.DetectAndReadInput(input, inputFormat)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error detecting or reading input: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">return reader</span>
}

func resolveModes() []string <span class="cov0" title="0">{
        modes := viper.GetStringSlice("modes")
        if len(modes) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No modes specified. Use --modes to specify what to run.")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if contains(modes, "all") </span><span class="cov0" title="0">{
                modes = []string{
                        "burndown-project", "overwrites-matrix", "ownership",
                        "couples-files", "couples-people", "couples-shotness",
                        "shotness", "devs", "devs-efforts",
                }
        }</span>
        <span class="cov0" title="0">return modes</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package cmd

import (
        "fmt"
        "labours-go/internal/modes"
        "labours-go/internal/readers"
        "time"

        "github.com/spf13/viper"
)

// Map of mode names to their handlers
var modeHandlers = map[string]func(reader readers.Reader, output string, startTime, endTime *time.Time) error{
        "burndown-project":  burndownProject,
        "burndown-file":     burndownFile,
        "burndown-person":   burndownPerson,
        "overwrites-matrix": overwritesMatrix,
        "ownership":         ownershipBurndown,
        "couples-files":     couplesFiles,
        "couples-people":    couplesPeople,
        "couples-shotness":  couplesShotness,
        "shotness":          shotness,
        "devs":              devs,
        "devs-efforts":      devsEfforts,
        "old-vs-new":        oldVsNew,
        "languages":         languages,
        "devs-parallel":     devsParallel,
        "run-times":         runTimes,
}

func executeModes(modes []string, reader readers.Reader, output string, startTime, endTime *time.Time) <span class="cov0" title="0">{
        for _, mode := range modes </span><span class="cov0" title="0">{
                fmt.Printf("Running mode: %s\n", mode)
                if modeFunc, ok := modeHandlers[mode]; ok </span><span class="cov0" title="0">{
                        if err := modeFunc(reader, output, startTime, endTime); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error in mode %s: %v\n", mode, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("Unknown mode: %s\n", mode)
                }</span>
        }
}

func burndownProject(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        relative := viper.GetBool("relative")
        resample := viper.GetString("resample")
        return modes.BurndownProject(reader, output, relative, startTime, endTime, resample)
}</span>

func burndownFile(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        relative := viper.GetBool("relative")
        resample := viper.GetString("resample")
        return modes.BurndownFile(reader, output, relative, startTime, endTime, resample)
}</span>

func burndownPerson(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        relative := viper.GetBool("relative")
        resample := viper.GetString("resample")
        return modes.BurndownPerson(reader, output, relative, startTime, endTime, resample)
}</span>

func overwritesMatrix(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        return modes.OverwritesMatrix(reader, output)
}</span>

func ownershipBurndown(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        return modes.OwnershipBurndown(reader, output)
}</span>

func couplesFiles(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        fmt.Println("Executing couples-files...")
        // Add logic for couples files
        return nil
}</span>

func couplesPeople(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        fmt.Println("Executing couples-people...")
        // Add logic for couples people
        return nil
}</span>

func couplesShotness(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        fmt.Println("Executing couples-shotness...")
        // Add logic for couples shotness
        return nil
}</span>

func shotness(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        fmt.Println("Executing shotness...")
        // Add logic for shotness
        return nil
}</span>

func devs(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        fmt.Println("Executing devs...")
        // Add logic for devs
        return nil
}</span>

func devsEfforts(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        fmt.Println("Executing devs-efforts...")
        // Add logic for devs efforts
        return nil
}</span>

func oldVsNew(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        fmt.Println("Executing old-vs-new...")
        // Add logic for old vs new
        return nil
}</span>

func languages(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        fmt.Println("Executing languages...")
        // Add logic for languages
        return nil
}</span>

func devsParallel(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        fmt.Println("Executing devs-parallel...")
        // Add logic for devs parallel
        return nil
}</span>

func runTimes(reader readers.Reader, output string, startTime, endTime *time.Time) error <span class="cov0" title="0">{
        fmt.Println("Executing run-times...")
        // Add logic for run times
        return nil
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package cmd

import (
        "fmt"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var rootCmd = &amp;cobra.Command{
        Use:   "labours",
        Short: "Labours CLI for analyzing git repository data",
        Long:  "Labours CLI for analyzing git repository data, visualizing trends, and generating reports.",
        Run:   runLaboursCommand,
}

func Execute() error <span class="cov0" title="0">{
        return rootCmd.Execute()
}</span>

func init() <span class="cov0" title="0">{
        cobra.OnInitialize(initConfig)
        initializeFlags()
        bindFlagsToViper()
}</span>

func initializeFlags() <span class="cov0" title="0">{
        rootCmd.PersistentFlags().StringP("output", "o", "", "Path to the output file/directory")
        rootCmd.PersistentFlags().StringP("input", "i", "-", "Path to the input file (- for stdin)")
        rootCmd.PersistentFlags().StringP("input-format", "f", "auto", "Input format (yaml, pb, auto)")
        rootCmd.PersistentFlags().Int("font-size", 12, "Size of the labels and legend")
        rootCmd.PersistentFlags().String("style", "ggplot", "Plot style to use")
        rootCmd.PersistentFlags().String("backend", "", "Matplotlib backend to use")
        rootCmd.PersistentFlags().String("background", "white", "Plot's general color scheme")
        rootCmd.PersistentFlags().String("size", "", "Axes' size in inches, e.g., '12,9'")
        rootCmd.PersistentFlags().Bool("relative", false, "Occupy 100% height for every measurement")
        rootCmd.PersistentFlags().String("tmpdir", "/tmp", "Temporary directory for intermediate files")
        rootCmd.PersistentFlags().StringSliceP("modes", "m", []string{}, "Modes to run (can be repeated)")
        rootCmd.PersistentFlags().String("resample", "year", "Resample interval for time series")
        rootCmd.PersistentFlags().String("start-date", "", "Start date for time-based plots")
        rootCmd.PersistentFlags().String("end-date", "", "End date for time-based plots")
        rootCmd.PersistentFlags().Bool("disable-projector", false, "Disable TensorFlow projector on couples")
        rootCmd.PersistentFlags().Int("max-people", 20, "Maximum number of developers in overwrites matrix and people plots.")
        rootCmd.PersistentFlags().Bool("order-ownership-by-time", false, "Sort developers in the ownership plot by their first appearance in the history.")
}</span>

func bindFlagsToViper() <span class="cov0" title="0">{
        viper.BindPFlags(rootCmd.PersistentFlags())
}</span>

func initConfig() <span class="cov0" title="0">{
        viper.SetConfigName("config")
        viper.SetConfigType("yaml")
        viper.AddConfigPath(".")
        viper.AddConfigPath("$HOME/.labours-go")

        if err := viper.ReadInConfig(); err == nil </span><span class="cov0" title="0">{
                fmt.Println("Using config file:", viper.ConfigFileUsed())
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("No configuration file found, using defaults.")
        }</span>
}

func runLaboursCommand(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        input, inputFormat := viper.GetString("input"), viper.GetString("input-format")
        startDate, endDate := parseDates()
        validateDateRange(startDate, endDate)

        reader := detectAndReadInput(input, inputFormat)
        modes := resolveModes()
        executeModes(modes, reader, viper.GetString("output"), startDate, endDate)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package graphics

import (
        "image/color"
        "math"

        "gonum.org/v1/plot"
        "gonum.org/v1/plot/vg"
        "gonum.org/v1/plot/vg/draw"
)

// CustomPalette represents a mapping of values to a predefined set of colors.
type CustomPalette struct {
        Colors []color.Color
        Min    float64
        Max    float64
}

// At maps a value to a corresponding color in the palette.
func (p *CustomPalette) At(value float64) color.Color <span class="cov0" title="0">{
        // Normalize the value to the range [0, 1].
        normalized := (value - p.Min) / (p.Max - p.Min)
        if normalized &lt; 0 </span><span class="cov0" title="0">{
                normalized = 0
        }</span> else<span class="cov0" title="0"> if normalized &gt; 1 </span><span class="cov0" title="0">{
                normalized = 1
        }</span>

        // Scale the normalized value to the palette size.
        <span class="cov0" title="0">index := int(math.Round(normalized * float64(len(p.Colors)-1)))
        return p.Colors[index]</span>
}

// HeatMap represents a heatmap plotter for a 2D matrix.
type HeatMap struct {
        Matrix  [][]float64
        Rows    []string
        Cols    []string
        Palette *CustomPalette
}

// NewHeatMap creates a new HeatMap with a custom palette.
func NewHeatMap(matrix [][]float64, rows, cols []string, palette *CustomPalette) *HeatMap <span class="cov0" title="0">{
        return &amp;HeatMap{
                Matrix:  matrix,
                Rows:    rows,
                Cols:    cols,
                Palette: palette,
        }
}</span>

// Plot draws the heatmap onto the plot canvas.
func (hm *HeatMap) Plot(c draw.Canvas, p *plot.Plot) <span class="cov0" title="0">{
        r := c.Rectangle.Size()
        cellWidth := r.X / vg.Length(len(hm.Cols))
        cellHeight := r.Y / vg.Length(len(hm.Rows))

        for rowIdx, row := range hm.Matrix </span><span class="cov0" title="0">{
                for colIdx, value := range row </span><span class="cov0" title="0">{
                        x := vg.Length(colIdx) * cellWidth
                        y := vg.Length(len(hm.Rows)-1-rowIdx) * cellHeight // Invert rows for correct orientation

                        // Map value to a color using the custom palette.
                        clr := hm.Palette.At(value)

                        // Define the coordinates for the cell.
                        xMin := c.Rectangle.Min.X + x
                        xMax := xMin + cellWidth
                        yMin := c.Rectangle.Min.Y + y
                        yMax := yMin + cellHeight

                        // Create a path for the rectangle.
                        path := vg.Path{
                                {Type: vg.MoveComp, Pos: vg.Point{X: xMin, Y: yMin}},
                                {Type: vg.LineComp, Pos: vg.Point{X: xMax, Y: yMin}},
                                {Type: vg.LineComp, Pos: vg.Point{X: xMax, Y: yMax}},
                                {Type: vg.LineComp, Pos: vg.Point{X: xMin, Y: yMax}},
                                {Type: vg.CloseComp},
                        }

                        // Set the fill color and fill the rectangle.
                        c.SetColor(clr)
                        c.Fill(path)
                }</span>
        }
}

// DataRange returns the minimum and maximum data range of the heatmap.
func (hm *HeatMap) DataRange() (xmin, xmax, ymin, ymax float64) <span class="cov0" title="0">{
        xmin, ymin = 0, 0
        xmax = float64(len(hm.Cols))
        ymax = float64(len(hm.Rows))
        return
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package graphics

import (
        "fmt"
        "image/color"
        "math"
        "time"

        "gonum.org/v1/plot"
        "gonum.org/v1/plot/plotter"
        "gonum.org/v1/plot/plotutil"
        "gonum.org/v1/plot/vg"
)

// PlotStackedBurndown generates a proper stacked area chart for burndown analysis
func PlotStackedBurndown(matrix [][]float64, dateRange []time.Time, output string, relative bool) error <span class="cov0" title="0">{
        if len(matrix) == 0 || len(dateRange) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("empty matrix or date range")
        }</span>

        // Create plot
        <span class="cov0" title="0">p := plot.New()
        p.Title.Text = "Burndown Chart"
        p.X.Label.Text = "Time"
        p.Y.Label.Text = "Lines of Code"
        if relative </span><span class="cov0" title="0">{
                p.Y.Label.Text = "Relative Fraction"
        }</span>

        // Ensure matrix dimensions are consistent
        <span class="cov0" title="0">numSeries := len(matrix)
        if numSeries == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("empty matrix")
        }</span>

        <span class="cov0" title="0">numPoints := len(matrix[0])
        if numPoints != len(dateRange) </span><span class="cov0" title="0">{
                // Adjust date range or matrix to match
                minLen := int(math.Min(float64(numPoints), float64(len(dateRange))))
                numPoints = minLen
                dateRange = dateRange[:minLen]
        }</span>

        // Convert dates to float64 for plotting (Unix timestamps)
        <span class="cov0" title="0">timeValues := make([]float64, numPoints)
        for i, date := range dateRange </span><span class="cov0" title="0">{
                timeValues[i] = float64(date.Unix())
        }</span>

        // Generate cumulative data for stacking
        <span class="cov0" title="0">cumulative := make([][]float64, numSeries)
        for i := range cumulative </span><span class="cov0" title="0">{
                cumulative[i] = make([]float64, numPoints)
                for j := 0; j &lt; numPoints &amp;&amp; j &lt; len(matrix[i]); j++ </span><span class="cov0" title="0">{
                        cumulative[i][j] = matrix[i][j]
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                cumulative[i][j] += cumulative[i-1][j]
                        }</span>
                }
        }

        // Color palette for different series
        <span class="cov0" title="0">colors := generateColorPalette(numSeries)

        // Create stacked areas (bottom to top)
        for i := numSeries - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                // Create data points for this layer
                var topPoints plotter.XYs
                var bottomPoints plotter.XYs

                for j := 0; j &lt; numPoints; j++ </span><span class="cov0" title="0">{
                        x := timeValues[j]
                        topY := cumulative[i][j]

                        var bottomY float64
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                bottomY = cumulative[i-1][j]
                        }</span> else<span class="cov0" title="0"> {
                                bottomY = 0
                        }</span>

                        <span class="cov0" title="0">topPoints = append(topPoints, plotter.XY{X: x, Y: topY})
                        bottomPoints = append(bottomPoints, plotter.XY{X: x, Y: bottomY})</span>
                }

                // Create polygon for this stacked area
                <span class="cov0" title="0">if err := addStackedLayer(p, topPoints, bottomPoints, colors[i], fmt.Sprintf("Layer %d", i)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error adding layer %d: %v", i, err)
                }</span>
        }

        // Configure time axis
        <span class="cov0" title="0">p.X.Tick.Marker = &amp;TimeTicker{Format: "2006-01-02"}

        // Set reasonable axis ranges
        if len(timeValues) &gt; 0 </span><span class="cov0" title="0">{
                p.X.Min = timeValues[0]
                p.X.Max = timeValues[len(timeValues)-1]
        }</span>

        // Save the plot
        <span class="cov0" title="0">width := 12 * vg.Inch
        height := 8 * vg.Inch
        if err := p.Save(width, height, output); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save plot to %s: %v", output, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// addStackedLayer adds a filled area between top and bottom curves
func addStackedLayer(p *plot.Plot, top, bottom plotter.XYs, fillColor color.Color, label string) error <span class="cov0" title="0">{
        if len(top) != len(bottom) </span><span class="cov0" title="0">{
                return fmt.Errorf("top and bottom point arrays must have equal length")
        }</span>

        // Create polygon points: top curve + reversed bottom curve
        <span class="cov0" title="0">points := make(plotter.XYs, len(top)+len(bottom))

        // Add top curve points
        copy(points[:len(top)], top)

        // Add bottom curve points in reverse order
        for i := range bottom </span><span class="cov0" title="0">{
                points[len(top)+i] = plotter.XY{X: bottom[len(bottom)-1-i].X, Y: bottom[len(bottom)-1-i].Y}
        }</span>

        // Create polygon plotter
        <span class="cov0" title="0">polygon, err := plotter.NewPolygon(points)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create polygon: %v", err)
        }</span>

        // Set fill color with some transparency
        <span class="cov0" title="0">polygon.Color = fillColor

        // Add to plot
        p.Add(polygon)

        // Add legend entry (just the top line for clarity)
        line, err := plotter.NewLine(top)
        if err == nil </span><span class="cov0" title="0">{
                line.Color = fillColor
                line.Width = vg.Points(2)
                p.Legend.Add(label, line)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// generateColorPalette creates a set of distinct colors for the chart
func generateColorPalette(n int) []color.Color <span class="cov0" title="0">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return []color.Color{}
        }</span>

        // Use predefined colors for better visibility
        <span class="cov0" title="0">baseColors := []color.Color{
                color.RGBA{R: 31, G: 119, B: 180, A: 150},  // Blue
                color.RGBA{R: 255, G: 127, B: 14, A: 150},  // Orange
                color.RGBA{R: 44, G: 160, B: 44, A: 150},   // Green
                color.RGBA{R: 214, G: 39, B: 40, A: 150},   // Red
                color.RGBA{R: 148, G: 103, B: 189, A: 150}, // Purple
                color.RGBA{R: 140, G: 86, B: 75, A: 150},   // Brown
                color.RGBA{R: 227, G: 119, B: 194, A: 150}, // Pink
                color.RGBA{R: 127, G: 127, B: 127, A: 150}, // Gray
                color.RGBA{R: 188, G: 189, B: 34, A: 150},  // Olive
                color.RGBA{R: 23, G: 190, B: 207, A: 150},  // Cyan
        }

        colors := make([]color.Color, n)
        for i := 0; i &lt; n; i++ </span><span class="cov0" title="0">{
                if i &lt; len(baseColors) </span><span class="cov0" title="0">{
                        colors[i] = baseColors[i]
                }</span> else<span class="cov0" title="0"> {
                        // Generate additional colors using HSV
                        colors[i] = generateHSVColor(i, n)
                }</span>
        }

        <span class="cov0" title="0">return colors</span>
}

// generateHSVColor generates colors using HSV color space for better distribution
func generateHSVColor(index, total int) color.Color <span class="cov0" title="0">{
        // Use golden angle for better color distribution
        goldenAngle := 137.508 // degrees
        hue := math.Mod(float64(index)*goldenAngle, 360)

        // Convert HSV to RGB
        saturation := 0.7
        value := 0.9

        c := value * saturation
        x := c * (1 - math.Abs(math.Mod(hue/60, 2)-1))
        m := value - c

        var r, g, b float64
        switch </span>{
        case hue &lt; 60:<span class="cov0" title="0">
                r, g, b = c, x, 0</span>
        case hue &lt; 120:<span class="cov0" title="0">
                r, g, b = x, c, 0</span>
        case hue &lt; 180:<span class="cov0" title="0">
                r, g, b = 0, c, x</span>
        case hue &lt; 240:<span class="cov0" title="0">
                r, g, b = 0, x, c</span>
        case hue &lt; 300:<span class="cov0" title="0">
                r, g, b = x, 0, c</span>
        default:<span class="cov0" title="0">
                r, g, b = c, 0, x</span>
        }

        <span class="cov0" title="0">return color.RGBA{
                R: uint8((r + m) * 255),
                G: uint8((g + m) * 255),
                B: uint8((b + m) * 255),
                A: 180, // Semi-transparent
        }</span>
}

// TimeTicker implements plot.Ticker for time-based axes
type TimeTicker struct {
        Format string
}

// Ticks generates tick marks for time axis
func (ticker *TimeTicker) Ticks(min, max float64) []plot.Tick <span class="cov0" title="0">{
        if ticker.Format == "" </span><span class="cov0" title="0">{
                ticker.Format = "2006-01-02"
        }</span>

        <span class="cov0" title="0">start := time.Unix(int64(min), 0)
        end := time.Unix(int64(max), 0)
        duration := end.Sub(start)

        var interval time.Duration
        var majorTicks []plot.Tick

        // Determine appropriate tick interval based on time range
        switch </span>{
        case duration &lt;= 24*time.Hour:<span class="cov0" title="0">
                interval = time.Hour</span>
        case duration &lt;= 7*24*time.Hour:<span class="cov0" title="0">
                interval = 24 * time.Hour</span>
        case duration &lt;= 30*24*time.Hour:<span class="cov0" title="0">
                interval = 7 * 24 * time.Hour</span>
        case duration &lt;= 365*24*time.Hour:<span class="cov0" title="0">
                interval = 30 * 24 * time.Hour</span>
        default:<span class="cov0" title="0">
                interval = 365 * 24 * time.Hour</span>
        }

        // Generate major ticks
        <span class="cov0" title="0">for t := start.Truncate(interval); t.Before(end) || t.Equal(end); t = t.Add(interval) </span><span class="cov0" title="0">{
                if t.Unix() &gt;= int64(min) &amp;&amp; t.Unix() &lt;= int64(max) </span><span class="cov0" title="0">{
                        majorTicks = append(majorTicks, plot.Tick{
                                Value: float64(t.Unix()),
                                Label: t.Format(ticker.Format),
                        })
                }</span>
        }

        <span class="cov0" title="0">return majorTicks</span>
}

// PlotHeatmap generates a heatmap visualization (placeholder for future ownership/overwrites charts)
func PlotHeatmap(matrix [][]float64, rowLabels, colLabels []string, output string, title string) error <span class="cov0" title="0">{
        p := plot.New()
        p.Title.Text = title

        // This would be implemented with a proper heatmap plotter
        // For now, return a placeholder implementation
        return fmt.Errorf("heatmap plotting not yet implemented")
}</span>

// PlotBarChart generates a bar chart (for developer statistics, language stats, etc.)
func PlotBarChart(values []float64, labels []string, output string, title string) error <span class="cov0" title="0">{
        if len(values) != len(labels) </span><span class="cov0" title="0">{
                return fmt.Errorf("values and labels must have the same length")
        }</span>

        <span class="cov0" title="0">p := plot.New()
        p.Title.Text = title
        p.Y.Label.Text = "Value"

        // Create bar chart data
        bars := make(plotter.Values, len(values))
        for i, v := range values </span><span class="cov0" title="0">{
                bars[i] = v
        }</span>

        // Create bar chart
        <span class="cov0" title="0">barChart, err := plotter.NewBarChart(bars, vg.Points(20))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating bar chart: %v", err)
        }</span>

        <span class="cov0" title="0">barChart.Color = plotutil.Color(0)
        p.Add(barChart)

        // Set custom x-axis labels
        p.NominalX(labels...)

        // Save plot
        if err := p.Save(10*vg.Inch, 6*vg.Inch, output); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save bar chart: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package modes

import (
        "fmt"
        "labours-go/internal/graphics"
        "os"
        "path/filepath"
        "time"

        "github.com/schollz/progressbar/v3"
)

// generateBurndownPlot creates the burndown plot with stacking, resampling, and survival ratio output.
func generateBurndownPlot(name string, matrix [][]int, output string, relative bool, startTime, endTime *time.Time, resample string) error <span class="cov3" title="7">{
        fmt.Println("Running: burndown-project")

        // Validate output path
        if output == "" </span><span class="cov0" title="0">{
                output = fmt.Sprintf("burndown_%s.png", name)
                fmt.Printf("Output not provided, using default: %s\n", output)
        }</span>

        <span class="cov3" title="7">outputDir := filepath.Dir(output)
        if err := os.MkdirAll(outputDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory %s: %v", outputDir, err)
        }</span>

        // Resampling logic
        <span class="cov3" title="7">if resample == "" </span><span class="cov0" title="0">{
                resample = "year"
        }</span>
        <span class="cov3" title="7">fmt.Printf("resampling to %s, please wait...\n", resample)

        // Use default endTime if not provided
        if endTime == nil </span><span class="cov0" title="0">{
                now := time.Now()
                endTime = &amp;now
        }</span>

        // Use earliest time in the matrix if startTime is not provided
        <span class="cov3" title="7">if startTime == nil </span><span class="cov0" title="0">{
                tickSize := time.Duration(365*24) * time.Hour // Assuming yearly granularity by default
                if resample == "month" </span><span class="cov0" title="0">{
                        tickSize = time.Duration(30*24) * time.Hour
                }</span> else<span class="cov0" title="0"> if resample == "day" </span><span class="cov0" title="0">{
                        tickSize = 24 * time.Hour
                }</span>
                <span class="cov0" title="0">earliest := findEarliestTime(matrix, tickSize, *endTime)
                startTime = &amp;earliest</span>
        }

        // Interpolation with progress bar
        <span class="cov3" title="7">interpolatedMatrix, dateRange := interpolateBurndownMatrix(matrix, *startTime, *endTime, resample)

        // Survival analysis
        survivalRatios := calculateSurvivalRatios(interpolatedMatrix, *startTime)
        printSurvivalRatios(survivalRatios)

        // Normalize if relative is true
        if relative </span><span class="cov1" title="1">{
                interpolatedMatrix = normalizeMatrix(interpolatedMatrix)
        }</span>

        // Create plot
        <span class="cov3" title="6">if err := graphics.PlotStackedBurndown(interpolatedMatrix, dateRange, output, relative); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating burndown plot: %v", err)
        }</span>

        <span class="cov3" title="6">fmt.Printf("Chart saved to %s\n", output)
        return nil</span>
}

// resampleDateRange creates a date range based on the given resampling interval.
func resampleDateRange(start, end time.Time, resample string) []time.Time <span class="cov3" title="6">{
        var dates []time.Time
        
        switch resample </span>{
        case "year":<span class="cov1" title="1">
                // Yearly samples - start of each year
                for year := start.Year(); year &lt;= end.Year(); year++ </span><span class="cov1" title="1">{
                        yearStart := time.Date(year, 1, 1, 0, 0, 0, 0, start.Location())
                        if yearStart.After(end) </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov1" title="1">if yearStart.After(start) || yearStart.Equal(start) </span><span class="cov1" title="1">{
                                dates = append(dates, yearStart)
                        }</span>
                }
                
        case "month", "M":<span class="cov1" title="1">
                // Monthly samples - start of each month
                current := time.Date(start.Year(), start.Month(), 1, 0, 0, 0, 0, start.Location())
                if current.Before(start) </span><span class="cov0" title="0">{
                        current = current.AddDate(0, 1, 0)
                }</span>
                
                <span class="cov1" title="1">for current.Before(end) || current.Equal(end) </span><span class="cov4" title="12">{
                        dates = append(dates, current)
                        current = current.AddDate(0, 1, 0)
                }</span>
                
        case "week", "W":<span class="cov1" title="1">
                // Weekly samples - start of each week (Monday)
                // Find the first Monday on or after start
                current := start
                for current.Weekday() != time.Monday </span><span class="cov0" title="0">{
                        current = current.AddDate(0, 0, 1)
                }</span>
                
                <span class="cov1" title="1">for current.Before(end) || current.Equal(end) </span><span class="cov5" title="53">{
                        dates = append(dates, current)
                        current = current.AddDate(0, 0, 7)
                }</span>
                
        case "day", "D":<span class="cov2" title="3">
                // Daily samples
                for current := start; current.Before(end) || current.Equal(end); current = current.AddDate(0, 0, 1) </span><span class="cov8" title="372">{
                        dates = append(dates, current)
                }</span>
                
        default:<span class="cov0" title="0">
                // Default to daily sampling
                for current := start; current.Before(end) || current.Equal(end); current = current.AddDate(0, 0, 1) </span><span class="cov0" title="0">{
                        dates = append(dates, current)
                }</span>
        }
        
        // Ensure we have at least two points for interpolation
        <span class="cov3" title="6">if len(dates) == 0 </span><span class="cov0" title="0">{
                dates = append(dates, start, end)
        }</span> else<span class="cov3" title="6"> if len(dates) == 1 </span><span class="cov1" title="1">{
                if !dates[0].Equal(end) </span><span class="cov1" title="1">{
                        dates = append(dates, end)
                }</span>
        }
        
        <span class="cov3" title="6">return dates</span>
}

// interpolateBurndownMatrix interpolates and resamples the matrix according to the specified interval
func interpolateBurndownMatrix(matrix [][]int, startTime, endTime time.Time, resample string) ([][]float64, []time.Time) <span class="cov3" title="7">{
        if len(matrix) == 0 || len(matrix[0]) == 0 </span><span class="cov1" title="1">{
                return [][]float64{}, []time.Time{}
        }</span>

        <span class="cov3" title="6">numBands := len(matrix)
        originalTicks := len(matrix[0])

        // Generate the target date range based on resampling
        dateRange := resampleDateRange(startTime, endTime, resample)
        targetTicks := len(dateRange)

        // Create interpolated matrix
        interpolated := make([][]float64, numBands)
        for i := range interpolated </span><span class="cov4" title="18">{
                interpolated[i] = make([]float64, targetTicks)
        }</span>

        <span class="cov3" title="6">bar := progressbar.Default(int64(numBands), "Interpolating burndown data")
        
        // Interpolate each band (developer/file/etc)
        for band := 0; band &lt; numBands; band++ </span><span class="cov4" title="18">{
                bar.Add(1)
                
                // If target resolution matches original, direct copy
                if targetTicks == originalTicks </span><span class="cov3" title="6">{
                        for tick := 0; tick &lt; originalTicks; tick++ </span><span class="cov4" title="18">{
                                interpolated[band][tick] = float64(matrix[band][tick])
                        }</span>
                        <span class="cov3" title="6">continue</span>
                }

                // Interpolate between original data points
                <span class="cov4" title="12">for targetTick := 0; targetTick &lt; targetTicks; targetTick++ </span><span class="cov9" title="1299">{
                        // Map target tick to original tick space
                        originalPos := float64(targetTick) * float64(originalTicks-1) / float64(targetTicks-1)
                        
                        // Find surrounding original ticks
                        leftTick := int(originalPos)
                        rightTick := leftTick + 1
                        
                        // Handle boundary cases
                        if leftTick &gt;= originalTicks-1 </span><span class="cov4" title="12">{
                                interpolated[band][targetTick] = float64(matrix[band][originalTicks-1])
                                continue</span>
                        }
                        <span class="cov9" title="1287">if rightTick &gt;= originalTicks </span><span class="cov0" title="0">{
                                interpolated[band][targetTick] = float64(matrix[band][leftTick])
                                continue</span>
                        }
                        
                        // Linear interpolation
                        <span class="cov9" title="1287">fraction := originalPos - float64(leftTick)
                        leftValue := float64(matrix[band][leftTick])
                        rightValue := float64(matrix[band][rightTick])
                        
                        interpolated[band][targetTick] = leftValue + fraction*(rightValue-leftValue)</span>
                }
        }

        <span class="cov3" title="6">return interpolated, dateRange</span>
}

// calculateSurvivalRatios computes survival ratios for the matrix.
func calculateSurvivalRatios(matrix [][]float64, startTime time.Time) map[int]float64 <span class="cov3" title="7">{
        survival := make(map[int]float64)
        total := 0.0

        for i := range matrix[0] </span><span class="cov8" title="439">{ // Iterate over columns (time ticks)
                alive := 0.0
                for _, row := range matrix </span><span class="cov10" title="1317">{
                        if row[i] &gt; 0 </span><span class="cov10" title="1317">{
                                alive += row[i]
                        }</span>
                }
                <span class="cov8" title="439">total += alive
                survival[i] = alive / total</span>
        }

        <span class="cov3" title="6">return survival</span>
}

// printSurvivalRatios prints the survival ratios to mimic the Python output.
func printSurvivalRatios(survival map[int]float64) <span class="cov3" title="6">{
        fmt.Println("           Ratio of survived lines")
        for days, ratio := range survival </span><span class="cov8" title="439">{
                fmt.Printf("%d days\t\t%.6f\n", days, ratio)
        }</span>
}

// normalizeMatrix normalizes each column to sum to 1.
func normalizeMatrix(matrix [][]float64) [][]float64 <span class="cov1" title="1">{
        for j := 0; j &lt; len(matrix[0]); j++ </span><span class="cov2" title="3">{
                sum := 0.0
                for i := 0; i &lt; len(matrix); i++ </span><span class="cov3" title="9">{
                        sum += matrix[i][j]
                }</span>
                <span class="cov2" title="3">if sum == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov2" title="3">for i := 0; i &lt; len(matrix); i++ </span><span class="cov3" title="9">{
                        matrix[i][j] /= sum
                }</span>
        }
        <span class="cov1" title="1">return matrix</span>
}

// findEarliestTime determines the earliest non-zero time entry in the data matrix.
func findEarliestTime(matrix [][]int, tickSize time.Duration, endTime time.Time) time.Time <span class="cov1" title="1">{
        for rowIndex, row := range matrix </span><span class="cov1" title="1">{
                for colIndex, val := range row </span><span class="cov1" title="1">{
                        if val &gt; 0 </span><span class="cov1" title="1">{
                                // Calculate the corresponding time for this column
                                earliestTime := endTime.Add(-tickSize * time.Duration(len(row)-colIndex))
                                fmt.Printf("Earliest time found at row %d, col %d: %s\n", rowIndex, colIndex, earliestTime)
                                return earliestTime
                        }</span>
                }
        }
        <span class="cov0" title="0">return time.Unix(0, 0)</span> // Fallback, should never hit if matrix has data
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package modes

import (
        "fmt"
        "labours-go/internal/readers"
        "time"
)

// BurndownFile generates burndown charts for individual files.
func BurndownFile(reader readers.Reader, output string, relative bool, startDate, endDate *time.Time, resample string) error <span class="cov0" title="0">{
        fileBurndowns, err := reader.GetFilesBurndown()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get files burndown data: %v", err)
        }</span>

        // Generate a chart for each file
        <span class="cov0" title="0">for _, file := range fileBurndowns </span><span class="cov0" title="0">{
                outputFile := fmt.Sprintf("%s_%s.png", output, file.Filename)
                if err := generateBurndownPlot(file.Filename, file.Matrix, outputFile, relative, startDate, endDate, resample); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate burndown for file %s: %v", file.Filename, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package modes

import (
        "fmt"
        "labours-go/internal/readers"
        "time"
)

// BurndownPerson generates burndown charts for individual people/developers.
func BurndownPerson(reader readers.Reader, output string, relative bool, startDate, endDate *time.Time, resample string) error <span class="cov0" title="0">{
        peopleBurndowns, err := reader.GetPeopleBurndown()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get people burndown data: %v", err)
        }</span>

        // Generate a chart for each person
        <span class="cov0" title="0">for _, person := range peopleBurndowns </span><span class="cov0" title="0">{
                outputFile := fmt.Sprintf("%s_%s.png", output, person.Person)
                if err := generateBurndownPlot(person.Person, person.Matrix, outputFile, relative, startDate, endDate, resample); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to generate burndown for person %s: %v", person.Person, err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package modes

import (
        "fmt"
        "labours-go/internal/readers"
        "time"
)

// BurndownProject generates a burndown chart for the entire project.
func BurndownProject(reader readers.Reader, output string, relative bool, startTime, endTime *time.Time, resample string) error <span class="cov0" title="0">{
        repoName, burndownMatrix := reader.GetProjectBurndown()
        if len(burndownMatrix) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no burndown data available for project")
        }</span>

        // Generate plot
        <span class="cov0" title="0">return generateBurndownPlot(repoName, burndownMatrix, output, relative, startTime, endTime, resample)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package modes

import (
        "fmt"
        "labours-go/internal/graphics"
        "labours-go/internal/readers"
        "path/filepath"
        "sort"

        "gonum.org/v1/plot"
        "gonum.org/v1/plot/plotter"
        "gonum.org/v1/plot/vg"
)

// Devs generates plots for individual developers' contributions over time.
func Devs(reader readers.Reader, output string, maxPeople int) error <span class="cov0" title="0">{
        // Step 1: Extract developer statistics
        developerStats, err := reader.GetDeveloperStats()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get developer stats: %v", err)
        }</span>

        <span class="cov0" title="0">if len(developerStats) &gt; maxPeople </span><span class="cov0" title="0">{
                fmt.Printf("Picking top %d developers by commit count.\n", maxPeople)
                developerStats = selectTopDevelopers(developerStats, maxPeople)
        }</span>

        // Step 2: Generate time series data for each developer
        <span class="cov0" title="0">devSeries := generateTimeSeries(developerStats)

        // Step 3: Cluster developers by contribution patterns (placeholder logic)
        clusters := clusterDevelopers(devSeries)

        // Step 4: Plot the developer contributions
        if err := plotDevs(developerStats, devSeries, clusters, output); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate developer plots: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Developer plots generated successfully.")
        return nil</span>
}

// selectTopDevelopers selects the top developers by commit count.
func selectTopDevelopers(stats []readers.DeveloperStat, maxPeople int) []readers.DeveloperStat <span class="cov0" title="0">{
        sort.Slice(stats, func(i, j int) bool </span><span class="cov0" title="0">{
                return stats[i].Commits &gt; stats[j].Commits
        }</span>)
        <span class="cov0" title="0">if len(stats) &gt; maxPeople </span><span class="cov0" title="0">{
                return stats[:maxPeople]
        }</span>
        <span class="cov0" title="0">return stats</span>
}

// generateTimeSeries generates synthetic time series data for each developer.
func generateTimeSeries(stats []readers.DeveloperStat) map[string][]float64 <span class="cov0" title="0">{
        devSeries := make(map[string][]float64)
        for _, stat := range stats </span><span class="cov0" title="0">{
                // Generate a synthetic time series based on commit activity
                // In a real implementation, this would come from daily or weekly data
                series := make([]float64, 52) // 52 weeks in a year
                commitsPerWeek := float64(stat.Commits) / 52.0
                for i := 0; i &lt; len(series); i++ </span><span class="cov0" title="0">{
                        // Add random variation to simulate real activity
                        series[i] = commitsPerWeek + float64(i%5)*0.1*commitsPerWeek
                }</span>
                <span class="cov0" title="0">devSeries[stat.Name] = series</span>
        }
        <span class="cov0" title="0">return devSeries</span>
}

// clusterDevelopers clusters developers based on their contribution patterns (placeholder logic).
func clusterDevelopers(devSeries map[string][]float64) map[string]int <span class="cov0" title="0">{
        // Placeholder logic: assign developers to arbitrary clusters
        clusters := make(map[string]int)
        i := 0
        for dev := range devSeries </span><span class="cov0" title="0">{
                clusters[dev] = i % 3 // Assign developers to 3 clusters
                i++
        }</span>
        <span class="cov0" title="0">return clusters</span>
}

// plotDevs generates plots for developers' contributions.
func plotDevs(developerStats []readers.DeveloperStat, devSeries map[string][]float64, clusters map[string]int, output string) error <span class="cov0" title="0">{
        // Create a new plot
        p := plot.New()
        p.Title.Text = "Developer Contributions Over Time"
        p.X.Label.Text = "Weeks"
        p.Y.Label.Text = "Commits"

        // Plot each developer's time series
        for _, dev := range developerStats </span><span class="cov0" title="0">{
                series := devSeries[dev.Name]
                pts := make(plotter.XYs, len(series))
                for i, val := range series </span><span class="cov0" title="0">{
                        pts[i].X = float64(i)
                        pts[i].Y = val
                }</span>

                <span class="cov0" title="0">line, err := plotter.NewLine(pts)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("error creating plot line for developer %s: %v", dev.Name, err)
                }</span>

                <span class="cov0" title="0">line.Color = graphics.ColorPalette[0] // Use the first color for now
                p.Add(line)
                p.Legend.Add(dev.Name, line)</span>
        }

        // Save the plot
        <span class="cov0" title="0">outputFile := filepath.Join(output, "developer_contributions.png")
        if err := p.Save(16*vg.Inch, 8*vg.Inch, outputFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save plot: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Saved developer plot to %s\n", outputFile)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package modes

import (
        "encoding/json"
        "fmt"
        "labours-go/internal/graphics"
        "labours-go/internal/readers"
        "os"
        "sort"
        "strings"

        "gonum.org/v1/plot"
        "gonum.org/v1/plot/vg"
)

func OverwritesMatrix(reader readers.Reader, output string) error <span class="cov0" title="0">{
        // Step 1: Extract data from the reader
        people, matrix, err := reader.GetPeopleInteraction()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get people interaction data: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Processing overwrites matrix...")

        // Step 2: Process the matrix
        maxPeople := 20 // This can be passed as a parameter or read from configuration
        people, normalizedMatrix := processOverwritesMatrix(people, matrix, maxPeople, true)

        // Step 3: Check if JSON output is required
        if strings.HasSuffix(output, ".json") </span><span class="cov0" title="0">{
                return saveMatrixAsJSON(output, people, normalizedMatrix)
        }</span>

        // Step 4: Visualize the matrix
        <span class="cov0" title="0">if err := plotOverwritesMatrix(people, normalizedMatrix, output); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to plot overwrites matrix: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Overwrites matrix generated successfully.")
        return nil</span>
}

func processOverwritesMatrix(people []string, matrix [][]int, maxPeople int, normalize bool) ([]string, [][]float64) <span class="cov0" title="0">{
        // Step 1: Truncate the matrix to the top `maxPeople` developers
        if len(people) &gt; maxPeople </span><span class="cov0" title="0">{
                order := argsort(matrix)
                matrix = truncateMatrix(matrix, order[:maxPeople])
                people = truncatePeople(people, order[:maxPeople])
                fmt.Printf("Warning: truncated people to most productive %d\n", maxPeople)
        }</span>

        // Step 2: Normalize the matrix to float64
        <span class="cov0" title="0">var normalizedMatrix [][]float64
        if normalize </span><span class="cov0" title="0">{
                normalizedMatrix = make([][]float64, len(matrix))
                for i := range matrix </span><span class="cov0" title="0">{
                        sum := sumRow(matrix[i])
                        normalizedMatrix[i] = make([]float64, len(matrix[i]))
                        for j := range matrix[i] </span><span class="cov0" title="0">{
                                if sum != 0 </span><span class="cov0" title="0">{
                                        normalizedMatrix[i][j] = float64(matrix[i][j]) / float64(sum)
                                }</span>
                        }
                }
        } else<span class="cov0" title="0"> {
                // Convert to float64 without normalization
                normalizedMatrix = make([][]float64, len(matrix))
                for i := range matrix </span><span class="cov0" title="0">{
                        normalizedMatrix[i] = make([]float64, len(matrix[i]))
                        for j := range matrix[i] </span><span class="cov0" title="0">{
                                normalizedMatrix[i][j] = float64(matrix[i][j])
                        }</span>
                }
        }

        // Step 3: Invert the matrix (make values negative as in Python)
        <span class="cov0" title="0">for i := range normalizedMatrix </span><span class="cov0" title="0">{
                for j := range normalizedMatrix[i] </span><span class="cov0" title="0">{
                        normalizedMatrix[i][j] = -normalizedMatrix[i][j]
                }</span>
        }

        // Step 4: Truncate long names
        <span class="cov0" title="0">for i, name := range people </span><span class="cov0" title="0">{
                if len(name) &gt; 40 </span><span class="cov0" title="0">{
                        people[i] = name[:37] + "..."
                }</span>
        }

        <span class="cov0" title="0">return people, normalizedMatrix</span>
}

func plotOverwritesMatrix(people []string, matrix [][]float64, output string) error <span class="cov0" title="0">{
        // Create and configure the plot
        p := plot.New()
        p.Title.Text = "Overwrites Matrix"
        p.X.Label.Text = "Developers"
        p.Y.Label.Text = "Developers"

        // Ensure the X and Y axis have proper labels
        p.X.Tick.Label.Rotation = -45 // Rotate X-axis labels for readability
        p.NominalX(people...)         // Use `people` as X-axis labels
        p.NominalY(people...)         // Use `people` as Y-axis labels

        // Create the heatmap with your custom palette
        palette := &amp;graphics.CustomPalette{
                Colors: graphics.ColorPalette, // Use your predefined palette
                Min:    -1.0,                  // Adjust Min and Max to align with normalized matrix values
                Max:    0.0,
        }
        heatmap := graphics.NewHeatMap(matrix, people, people, palette)

        // Add the heatmap to the plot
        p.Add(heatmap)

        // Save the plot
        if err := p.Save(10*vg.Inch, 10*vg.Inch, output); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save plot: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func saveMatrixAsJSON(output string, people []string, matrix [][]float64) error <span class="cov0" title="0">{
        data := struct {
                Type   string      `json:"type"`
                People []string    `json:"people"`
                Matrix [][]float64 `json:"matrix"`
        }{
                Type:   "overwrites_matrix",
                People: people,
                Matrix: matrix,
        }

        file, err := os.Create(output)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create JSON output file: %v", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := json.NewEncoder(file)
        encoder.SetIndent("", "  ")
        return encoder.Encode(data)</span>
}

func truncateMatrix(matrix [][]int, indices []int) [][]int <span class="cov0" title="0">{
        truncated := make([][]int, len(indices))
        for i, idx := range indices </span><span class="cov0" title="0">{
                if idx &gt;= len(matrix) </span><span class="cov0" title="0">{
                        continue</span> // Skip invalid indices
                }
                <span class="cov0" title="0">truncated[i] = make([]int, len(indices))
                for j, jdx := range indices </span><span class="cov0" title="0">{
                        if jdx &lt; len(matrix[idx]) </span><span class="cov0" title="0">{
                                truncated[i][j] = matrix[idx][jdx]
                        }</span>
                }
        }
        <span class="cov0" title="0">return truncated</span>
}

func truncatePeople(people []string, indices []int) []string <span class="cov0" title="0">{
        truncated := make([]string, len(indices))
        for i, idx := range indices </span><span class="cov0" title="0">{
                truncated[i] = people[idx]
        }</span>
        <span class="cov0" title="0">return truncated</span>
}

func sumRow(row []int) int <span class="cov0" title="0">{
        sum := 0
        for _, val := range row </span><span class="cov0" title="0">{
                sum += val
        }</span>
        <span class="cov0" title="0">return sum</span>
}

func argsort(matrix [][]int) []int <span class="cov0" title="0">{
        scores := make([]int, len(matrix))
        for i, row := range matrix </span><span class="cov0" title="0">{
                scores[i] = row[0]
        }</span>

        <span class="cov0" title="0">indices := make([]int, len(scores))
        for i := range indices </span><span class="cov0" title="0">{
                indices[i] = i
        }</span>

        <span class="cov0" title="0">sort.Slice(indices, func(i, j int) bool </span><span class="cov0" title="0">{
                return scores[indices[i]] &gt; scores[indices[j]]
        }</span>)

        <span class="cov0" title="0">return indices</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package modes

import (
        "encoding/json"
        "fmt"
        "labours-go/internal/graphics"
        "labours-go/internal/readers"
        "math"
        "os"
        "path/filepath"
        "sort"
        "time"

        "gonum.org/v1/plot"
        "gonum.org/v1/plot/plotter"
        "gonum.org/v1/plot/vg"
)

func OwnershipBurndown(reader readers.Reader, output string) error <span class="cov0" title="0">{
        // Validate output path
        if output == "" </span><span class="cov0" title="0">{
                output = "ownership.png"
                fmt.Printf("Output not provided, using default: %s\n", output)
        }</span>

        <span class="cov0" title="0">outputDir := filepath.Dir(output)
        if err := os.MkdirAll(outputDir, os.ModePerm); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create output directory %s: %v", outputDir, err)
        }</span>

        // Step 1: Extract data from the reader
        <span class="cov0" title="0">peopleSequence, ownershipData, err := reader.GetOwnershipBurndown()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get ownership burndown data: %v", err)
        }</span>

        // Metadata for the timeline (hardcoded sampling for simplicity)
        <span class="cov0" title="0">sampling := 1                // Assume daily sampling
        startTime := time.Unix(0, 0) // Placeholder for start time; replace with actual value if needed
        lastTime := startTime.Add(time.Duration(len(ownershipData[peopleSequence[0]][0])*sampling) * 24 * time.Hour)

        // Step 2: Process the data
        maxPeople := 20      // Maximum number of people to display
        orderByTime := false // Sort developers by their first appearance
        names, peopleMatrix, dateRange := processOwnershipBurndown(
                startTime, lastTime, sampling, peopleSequence, ownershipData, maxPeople, orderByTime)

        // Step 3: Check if JSON output is required
        if filepath.Ext(output) == ".json" </span><span class="cov0" title="0">{
                return saveOwnershipBurndownAsJSON(output, names, peopleMatrix, dateRange, lastTime)
        }</span>

        // Step 4: Visualize the data
        <span class="cov0" title="0">if err := plotOwnershipBurndown(names, peopleMatrix, dateRange, lastTime, output); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to plot ownership burndown: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("Ownership burndown chart generated successfully.")
        return nil</span>
}

func processOwnershipBurndown(
        start, last time.Time, sampling int,
        sequence []string, data map[string][][]int,
        maxPeople int, orderByTime bool,
) ([]string, [][]float64, []time.Time) <span class="cov0" title="0">{
        // Aggregate the ownership data
        people := make([][]float64, len(sequence))
        for i, name := range sequence </span><span class="cov0" title="0">{
                rows := data[name]
                total := make([]float64, len(rows[0]))
                for _, row := range rows </span><span class="cov0" title="0">{
                        for j, val := range row </span><span class="cov0" title="0">{
                                total[j] += float64(val)
                        }</span>
                }
                <span class="cov0" title="0">people[i] = total</span>
        }

        // Create a date range based on sampling
        <span class="cov0" title="0">dateRange := make([]time.Time, len(people[0]))
        for i := 0; i &lt; len(dateRange); i++ </span><span class="cov0" title="0">{
                dateRange[i] = start.Add(time.Duration(i*sampling) * time.Hour * 24)
        }</span>

        // Truncate to maxPeople
        <span class="cov0" title="0">if len(people) &gt; maxPeople </span><span class="cov0" title="0">{
                sums := make([]float64, len(people))
                for i, row := range people </span><span class="cov0" title="0">{
                        for _, val := range row </span><span class="cov0" title="0">{
                                sums[i] += val
                        }</span>
                }

                <span class="cov0" title="0">indices := argsortDescending(sums)
                chosen := indices[:maxPeople]
                others := indices[maxPeople:]

                // Aggregate "others"
                othersTotal := make([]float64, len(people[0]))
                for _, idx := range others </span><span class="cov0" title="0">{
                        for j, val := range people[idx] </span><span class="cov0" title="0">{
                                othersTotal[j] += val
                        }</span>
                }

                // Update people and sequence
                <span class="cov0" title="0">truncatedPeople := make([][]float64, maxPeople+1)
                truncatedNames := make([]string, maxPeople+1)
                for i, idx := range chosen </span><span class="cov0" title="0">{
                        truncatedPeople[i] = people[idx]
                        truncatedNames[i] = sequence[idx]
                }</span>
                <span class="cov0" title="0">truncatedPeople[maxPeople] = othersTotal
                truncatedNames[maxPeople] = "others"

                people = truncatedPeople
                sequence = truncatedNames</span>
        }

        // Sort by first appearance or total ownership
        <span class="cov0" title="0">if orderByTime </span><span class="cov0" title="0">{
                appearances := make([]int, len(people))
                for i, row := range people </span><span class="cov0" title="0">{
                        appearances[i] = findFirstNonZero(row)
                }</span>
                <span class="cov0" title="0">indices := argsortAscending(appearances)
                people = reorder(people, indices)
                sequence = reorderStrings(sequence, indices)</span>
        } else<span class="cov0" title="0"> {
                totalOwnership := make([]float64, len(people))
                for i, row := range people </span><span class="cov0" title="0">{
                        for _, val := range row </span><span class="cov0" title="0">{
                                totalOwnership[i] += val
                        }</span>
                }
                <span class="cov0" title="0">indices := argsortDescending(totalOwnership)
                people = reorder(people, indices)
                sequence = reorderStrings(sequence, indices)</span>
        }

        <span class="cov0" title="0">return sequence, people, dateRange</span>
}

func plotOwnershipBurndown(names []string, people [][]float64, dateRange []time.Time, lastTime time.Time, output string) error <span class="cov0" title="0">{
        // Create a plot
        p := plot.New()
        p.Title.Text = "Ownership Burndown"
        p.X.Label.Text = "Time"
        p.Y.Label.Text = "Ownership"

        // Convert people data into plotter.XYs
        stackData := make([]plotter.XYs, len(people))
        for i, row := range people </span><span class="cov0" title="0">{
                points := make(plotter.XYs, len(row))
                for j, val := range row </span><span class="cov0" title="0">{
                        points[j].X = float64(dateRange[j].Unix())
                        points[j].Y = val
                }</span>
                <span class="cov0" title="0">stackData[i] = points</span>
        }

        // Add stackplot layers
        <span class="cov0" title="0">for i, points := range stackData </span><span class="cov0" title="0">{
                line, err := plotter.NewLine(points)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create line plot: %v", err)
                }</span>
                <span class="cov0" title="0">line.Color = graphics.ColorPalette[i%len(graphics.ColorPalette)]
                p.Add(line)
                p.Legend.Add(names[i], line)</span>
        }

        // Save the plot
        <span class="cov0" title="0">if err := p.Save(10*vg.Inch, 5*vg.Inch, output); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save plot: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func saveOwnershipBurndownAsJSON(output string, names []string, people [][]float64, dateRange []time.Time, lastTime time.Time) error <span class="cov0" title="0">{
        data := struct {
                Type      string      `json:"type"`
                Names     []string    `json:"names"`
                People    [][]float64 `json:"people"`
                DateRange []time.Time `json:"date_range"`
                Last      time.Time   `json:"last"`
        }{
                Type:      "ownership",
                Names:     names,
                People:    people,
                DateRange: dateRange,
                Last:      lastTime,
        }

        file, err := os.Create(output)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create JSON output file: %v", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := json.NewEncoder(file)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write JSON data: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("JSON data saved to %s\n", output)
        return nil</span>
}

func argsortDescending(data []float64) []int <span class="cov0" title="0">{
        indices := make([]int, len(data))
        for i := range indices </span><span class="cov0" title="0">{
                indices[i] = i
        }</span>
        <span class="cov0" title="0">sort.Slice(indices, func(i, j int) bool </span><span class="cov0" title="0">{
                return data[indices[i]] &gt; data[indices[j]]
        }</span>)
        <span class="cov0" title="0">return indices</span>
}

func argsortAscending(data []int) []int <span class="cov0" title="0">{
        indices := make([]int, len(data))
        for i := range indices </span><span class="cov0" title="0">{
                indices[i] = i
        }</span>
        <span class="cov0" title="0">sort.Slice(indices, func(i, j int) bool </span><span class="cov0" title="0">{
                return data[indices[i]] &lt; data[indices[j]]
        }</span>)
        <span class="cov0" title="0">return indices</span>
}

func findFirstNonZero(row []float64) int <span class="cov0" title="0">{
        for i, val := range row </span><span class="cov0" title="0">{
                if val &gt; 0 </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return math.MaxInt</span>
}

func reorder(data [][]float64, indices []int) [][]float64 <span class="cov0" title="0">{
        reordered := make([][]float64, len(indices))
        for i, idx := range indices </span><span class="cov0" title="0">{
                reordered[i] = data[idx]
        }</span>
        <span class="cov0" title="0">return reordered</span>
}

func reorderStrings(data []string, indices []int) []string <span class="cov0" title="0">{
        reordered := make([]string, len(indices))
        for i, idx := range indices </span><span class="cov0" title="0">{
                reordered[i] = data[idx]
        }</span>
        <span class="cov0" title="0">return reordered</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.36.6
//         protoc        v3.20.3
// source: pb.proto

package pb

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
        unsafe "unsafe"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Main analysis result container
type BurndownAnalysisResults struct {
        state             protoimpl.MessageState     `protogen:"open.v1"`
        Project           *CompressedSparseRowMatrix `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
        Files             *CompressedSparseRowMatrix `protobuf:"bytes,2,opt,name=files,proto3" json:"files,omitempty"`
        People            *CompressedSparseRowMatrix `protobuf:"bytes,3,opt,name=people,proto3" json:"people,omitempty"`
        PeopleInteraction *CompressedSparseRowMatrix `protobuf:"bytes,4,opt,name=people_interaction,json=peopleInteraction,proto3" json:"people_interaction,omitempty"`
        FilesOwnership    *FilesOwnership            `protobuf:"bytes,5,opt,name=files_ownership,json=filesOwnership,proto3" json:"files_ownership,omitempty"`
        TickSize          int32                      `protobuf:"varint,6,opt,name=tick_size,json=tickSize,proto3" json:"tick_size,omitempty"`
        unknownFields     protoimpl.UnknownFields
        sizeCache         protoimpl.SizeCache
}

func (x *BurndownAnalysisResults) Reset() <span class="cov0" title="0">{
        *x = BurndownAnalysisResults{}
        mi := &amp;file_pb_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *BurndownAnalysisResults) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BurndownAnalysisResults) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BurndownAnalysisResults) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pb_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use BurndownAnalysisResults.ProtoReflect.Descriptor instead.
func (*BurndownAnalysisResults) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pb_proto_rawDescGZIP(), []int{0}
}</span>

func (x *BurndownAnalysisResults) GetProject() *CompressedSparseRowMatrix <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BurndownAnalysisResults) GetFiles() *CompressedSparseRowMatrix <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Files
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BurndownAnalysisResults) GetPeople() *CompressedSparseRowMatrix <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.People
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BurndownAnalysisResults) GetPeopleInteraction() *CompressedSparseRowMatrix <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PeopleInteraction
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BurndownAnalysisResults) GetFilesOwnership() *FilesOwnership <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FilesOwnership
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *BurndownAnalysisResults) GetTickSize() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TickSize
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Efficient sparse matrix representation using Compressed Sparse Row format
type CompressedSparseRowMatrix struct {
        state           protoimpl.MessageState `protogen:"open.v1"`
        NumberOfRows    int32                  `protobuf:"varint,1,opt,name=number_of_rows,json=numberOfRows,proto3" json:"number_of_rows,omitempty"`
        NumberOfColumns int32                  `protobuf:"varint,2,opt,name=number_of_columns,json=numberOfColumns,proto3" json:"number_of_columns,omitempty"`
        Data            []int64                `protobuf:"varint,3,rep,packed,name=data,proto3" json:"data,omitempty"`
        Indices         []int32                `protobuf:"varint,4,rep,packed,name=indices,proto3" json:"indices,omitempty"`
        Indptr          []int64                `protobuf:"varint,5,rep,packed,name=indptr,proto3" json:"indptr,omitempty"`
        unknownFields   protoimpl.UnknownFields
        sizeCache       protoimpl.SizeCache
}

func (x *CompressedSparseRowMatrix) Reset() <span class="cov0" title="0">{
        *x = CompressedSparseRowMatrix{}
        mi := &amp;file_pb_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CompressedSparseRowMatrix) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CompressedSparseRowMatrix) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CompressedSparseRowMatrix) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pb_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CompressedSparseRowMatrix.ProtoReflect.Descriptor instead.
func (*CompressedSparseRowMatrix) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pb_proto_rawDescGZIP(), []int{1}
}</span>

func (x *CompressedSparseRowMatrix) GetNumberOfRows() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NumberOfRows
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CompressedSparseRowMatrix) GetNumberOfColumns() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NumberOfColumns
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *CompressedSparseRowMatrix) GetData() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Data
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CompressedSparseRowMatrix) GetIndices() []int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Indices
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CompressedSparseRowMatrix) GetIndptr() []int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Indptr
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// File ownership data mapping file paths to developer indices
type FilesOwnership struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Value         map[string]int32       `protobuf:"bytes,1,rep,name=value,proto3" json:"value,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *FilesOwnership) Reset() <span class="cov0" title="0">{
        *x = FilesOwnership{}
        mi := &amp;file_pb_proto_msgTypes[2]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *FilesOwnership) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FilesOwnership) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FilesOwnership) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pb_proto_msgTypes[2]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FilesOwnership.ProtoReflect.Descriptor instead.
func (*FilesOwnership) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pb_proto_rawDescGZIP(), []int{2}
}</span>

func (x *FilesOwnership) GetValue() map[string]int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Repository metadata
type Metadata struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Version       int32                  `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
        Hash          string                 `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
        Repository    string                 `protobuf:"bytes,3,opt,name=repository,proto3" json:"repository,omitempty"`
        BeginUnixTime int64                  `protobuf:"varint,4,opt,name=begin_unix_time,json=beginUnixTime,proto3" json:"begin_unix_time,omitempty"`
        EndUnixTime   int64                  `protobuf:"varint,5,opt,name=end_unix_time,json=endUnixTime,proto3" json:"end_unix_time,omitempty"`
        Commits       int32                  `protobuf:"varint,6,opt,name=commits,proto3" json:"commits,omitempty"`
        RunTime       int64                  `protobuf:"varint,7,opt,name=run_time,json=runTime,proto3" json:"run_time,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *Metadata) Reset() <span class="cov0" title="0">{
        *x = Metadata{}
        mi := &amp;file_pb_proto_msgTypes[3]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *Metadata) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Metadata) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Metadata) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pb_proto_msgTypes[3]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Metadata.ProtoReflect.Descriptor instead.
func (*Metadata) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pb_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Metadata) GetVersion() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Metadata) GetHash() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Hash
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Metadata) GetRepository() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Repository
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Metadata) GetBeginUnixTime() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BeginUnixTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Metadata) GetEndUnixTime() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EndUnixTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Metadata) GetCommits() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Commits
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Metadata) GetRunTime() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RunTime
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// File coupling analysis results
type CouplesAnalysisResults struct {
        state         protoimpl.MessageState     `protogen:"open.v1"`
        FileCouples   *CompressedSparseRowMatrix `protobuf:"bytes,1,opt,name=file_couples,json=fileCouples,proto3" json:"file_couples,omitempty"`
        FileNames     []string                   `protobuf:"bytes,2,rep,name=file_names,json=fileNames,proto3" json:"file_names,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *CouplesAnalysisResults) Reset() <span class="cov0" title="0">{
        *x = CouplesAnalysisResults{}
        mi := &amp;file_pb_proto_msgTypes[4]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *CouplesAnalysisResults) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*CouplesAnalysisResults) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *CouplesAnalysisResults) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pb_proto_msgTypes[4]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use CouplesAnalysisResults.ProtoReflect.Descriptor instead.
func (*CouplesAnalysisResults) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pb_proto_rawDescGZIP(), []int{4}
}</span>

func (x *CouplesAnalysisResults) GetFileCouples() *CompressedSparseRowMatrix <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileCouples
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *CouplesAnalysisResults) GetFileNames() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileNames
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Developer statistics
type DeveloperStat struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Commits       int32                  `protobuf:"varint,2,opt,name=commits,proto3" json:"commits,omitempty"`
        LinesAdded    int64                  `protobuf:"varint,3,opt,name=lines_added,json=linesAdded,proto3" json:"lines_added,omitempty"`
        LinesRemoved  int64                  `protobuf:"varint,4,opt,name=lines_removed,json=linesRemoved,proto3" json:"lines_removed,omitempty"`
        LinesModified int64                  `protobuf:"varint,5,opt,name=lines_modified,json=linesModified,proto3" json:"lines_modified,omitempty"`
        FilesTouched  int32                  `protobuf:"varint,6,opt,name=files_touched,json=filesTouched,proto3" json:"files_touched,omitempty"`
        Languages     map[string]int32       `protobuf:"bytes,7,rep,name=languages,proto3" json:"languages,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *DeveloperStat) Reset() <span class="cov0" title="0">{
        *x = DeveloperStat{}
        mi := &amp;file_pb_proto_msgTypes[5]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *DeveloperStat) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DeveloperStat) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DeveloperStat) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pb_proto_msgTypes[5]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DeveloperStat.ProtoReflect.Descriptor instead.
func (*DeveloperStat) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pb_proto_rawDescGZIP(), []int{5}
}</span>

func (x *DeveloperStat) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DeveloperStat) GetCommits() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Commits
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DeveloperStat) GetLinesAdded() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LinesAdded
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DeveloperStat) GetLinesRemoved() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LinesRemoved
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DeveloperStat) GetLinesModified() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LinesModified
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DeveloperStat) GetFilesTouched() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FilesTouched
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *DeveloperStat) GetLanguages() map[string]int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Languages
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Language statistics
type LanguageStat struct {
        state         protoimpl.MessageState `protogen:"open.v1"`
        Language      string                 `protobuf:"bytes,1,opt,name=language,proto3" json:"language,omitempty"`
        Lines         int64                  `protobuf:"varint,2,opt,name=lines,proto3" json:"lines,omitempty"`
        unknownFields protoimpl.UnknownFields
        sizeCache     protoimpl.SizeCache
}

func (x *LanguageStat) Reset() <span class="cov0" title="0">{
        *x = LanguageStat{}
        mi := &amp;file_pb_proto_msgTypes[6]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *LanguageStat) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LanguageStat) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LanguageStat) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pb_proto_msgTypes[6]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LanguageStat.ProtoReflect.Descriptor instead.
func (*LanguageStat) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pb_proto_rawDescGZIP(), []int{6}
}</span>

func (x *LanguageStat) GetLanguage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Language
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LanguageStat) GetLines() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Lines
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Comprehensive analysis results that can contain multiple analysis types
type AnalysisResults struct {
        state          protoimpl.MessageState   `protogen:"open.v1"`
        Metadata       *Metadata                `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
        Burndown       *BurndownAnalysisResults `protobuf:"bytes,2,opt,name=burndown,proto3" json:"burndown,omitempty"`
        Couples        *CouplesAnalysisResults  `protobuf:"bytes,3,opt,name=couples,proto3" json:"couples,omitempty"`
        DeveloperStats []*DeveloperStat         `protobuf:"bytes,4,rep,name=developer_stats,json=developerStats,proto3" json:"developer_stats,omitempty"`
        LanguageStats  []*LanguageStat          `protobuf:"bytes,5,rep,name=language_stats,json=languageStats,proto3" json:"language_stats,omitempty"`
        PeopleNames    []string                 `protobuf:"bytes,6,rep,name=people_names,json=peopleNames,proto3" json:"people_names,omitempty"`
        FileNames      []string                 `protobuf:"bytes,7,rep,name=file_names,json=fileNames,proto3" json:"file_names,omitempty"`
        unknownFields  protoimpl.UnknownFields
        sizeCache      protoimpl.SizeCache
}

func (x *AnalysisResults) Reset() <span class="cov0" title="0">{
        *x = AnalysisResults{}
        mi := &amp;file_pb_proto_msgTypes[7]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *AnalysisResults) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*AnalysisResults) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *AnalysisResults) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_pb_proto_msgTypes[7]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use AnalysisResults.ProtoReflect.Descriptor instead.
func (*AnalysisResults) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_pb_proto_rawDescGZIP(), []int{7}
}</span>

func (x *AnalysisResults) GetMetadata() *Metadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AnalysisResults) GetBurndown() *BurndownAnalysisResults <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Burndown
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AnalysisResults) GetCouples() *CouplesAnalysisResults <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Couples
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AnalysisResults) GetDeveloperStats() []*DeveloperStat <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DeveloperStats
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AnalysisResults) GetLanguageStats() []*LanguageStat <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LanguageStats
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AnalysisResults) GetPeopleNames() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PeopleNames
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *AnalysisResults) GetFileNames() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileNames
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_pb_proto protoreflect.FileDescriptor

const file_pb_proto_rawDesc = "" +
        "\n" +
        "\bpb.proto\x12\x02pb\"\xe6\x02\n" +
        "\x17BurndownAnalysisResults\x127\n" +
        "\aproject\x18\x01 \x01(\v2\x1d.pb.CompressedSparseRowMatrixR\aproject\x123\n" +
        "\x05files\x18\x02 \x01(\v2\x1d.pb.CompressedSparseRowMatrixR\x05files\x125\n" +
        "\x06people\x18\x03 \x01(\v2\x1d.pb.CompressedSparseRowMatrixR\x06people\x12L\n" +
        "\x12people_interaction\x18\x04 \x01(\v2\x1d.pb.CompressedSparseRowMatrixR\x11peopleInteraction\x12;\n" +
        "\x0ffiles_ownership\x18\x05 \x01(\v2\x12.pb.FilesOwnershipR\x0efilesOwnership\x12\x1b\n" +
        "\ttick_size\x18\x06 \x01(\x05R\btickSize\"\xb3\x01\n" +
        "\x19CompressedSparseRowMatrix\x12$\n" +
        "\x0enumber_of_rows\x18\x01 \x01(\x05R\fnumberOfRows\x12*\n" +
        "\x11number_of_columns\x18\x02 \x01(\x05R\x0fnumberOfColumns\x12\x12\n" +
        "\x04data\x18\x03 \x03(\x03R\x04data\x12\x18\n" +
        "\aindices\x18\x04 \x03(\x05R\aindices\x12\x16\n" +
        "\x06indptr\x18\x05 \x03(\x03R\x06indptr\"\x7f\n" +
        "\x0eFilesOwnership\x123\n" +
        "\x05value\x18\x01 \x03(\v2\x1d.pb.FilesOwnership.ValueEntryR\x05value\x1a8\n" +
        "\n" +
        "ValueEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"\xd9\x01\n" +
        "\bMetadata\x12\x18\n" +
        "\aversion\x18\x01 \x01(\x05R\aversion\x12\x12\n" +
        "\x04hash\x18\x02 \x01(\tR\x04hash\x12\x1e\n" +
        "\n" +
        "repository\x18\x03 \x01(\tR\n" +
        "repository\x12&amp;\n" +
        "\x0fbegin_unix_time\x18\x04 \x01(\x03R\rbeginUnixTime\x12\"\n" +
        "\rend_unix_time\x18\x05 \x01(\x03R\vendUnixTime\x12\x18\n" +
        "\acommits\x18\x06 \x01(\x05R\acommits\x12\x19\n" +
        "\brun_time\x18\a \x01(\x03R\arunTime\"y\n" +
        "\x16CouplesAnalysisResults\x12@\n" +
        "\ffile_couples\x18\x01 \x01(\v2\x1d.pb.CompressedSparseRowMatrixR\vfileCouples\x12\x1d\n" +
        "\n" +
        "file_names\x18\x02 \x03(\tR\tfileNames\"\xcd\x02\n" +
        "\rDeveloperStat\x12\x12\n" +
        "\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
        "\acommits\x18\x02 \x01(\x05R\acommits\x12\x1f\n" +
        "\vlines_added\x18\x03 \x01(\x03R\n" +
        "linesAdded\x12#\n" +
        "\rlines_removed\x18\x04 \x01(\x03R\flinesRemoved\x12%\n" +
        "\x0elines_modified\x18\x05 \x01(\x03R\rlinesModified\x12#\n" +
        "\rfiles_touched\x18\x06 \x01(\x05R\ffilesTouched\x12&gt;\n" +
        "\tlanguages\x18\a \x03(\v2 .pb.DeveloperStat.LanguagesEntryR\tlanguages\x1a&lt;\n" +
        "\x0eLanguagesEntry\x12\x10\n" +
        "\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
        "\x05value\x18\x02 \x01(\x05R\x05value:\x028\x01\"@\n" +
        "\fLanguageStat\x12\x1a\n" +
        "\blanguage\x18\x01 \x01(\tR\blanguage\x12\x14\n" +
        "\x05lines\x18\x02 \x01(\x03R\x05lines\"\xe1\x02\n" +
        "\x0fAnalysisResults\x12(\n" +
        "\bmetadata\x18\x01 \x01(\v2\f.pb.MetadataR\bmetadata\x127\n" +
        "\bburndown\x18\x02 \x01(\v2\x1b.pb.BurndownAnalysisResultsR\bburndown\x124\n" +
        "\acouples\x18\x03 \x01(\v2\x1a.pb.CouplesAnalysisResultsR\acouples\x12:\n" +
        "\x0fdeveloper_stats\x18\x04 \x03(\v2\x11.pb.DeveloperStatR\x0edeveloperStats\x127\n" +
        "\x0elanguage_stats\x18\x05 \x03(\v2\x10.pb.LanguageStatR\rlanguageStats\x12!\n" +
        "\fpeople_names\x18\x06 \x03(\tR\vpeopleNames\x12\x1d\n" +
        "\n" +
        "file_names\x18\a \x03(\tR\tfileNamesB\x18Z\x16labours-go/internal/pbb\x06proto3"

var (
        file_pb_proto_rawDescOnce sync.Once
        file_pb_proto_rawDescData []byte
)

func file_pb_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_pb_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_pb_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_pb_proto_rawDesc), len(file_pb_proto_rawDesc)))
        }</span>)
        <span class="cov0" title="0">return file_pb_proto_rawDescData</span>
}

var file_pb_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_pb_proto_goTypes = []any{
        (*BurndownAnalysisResults)(nil),   // 0: pb.BurndownAnalysisResults
        (*CompressedSparseRowMatrix)(nil), // 1: pb.CompressedSparseRowMatrix
        (*FilesOwnership)(nil),            // 2: pb.FilesOwnership
        (*Metadata)(nil),                  // 3: pb.Metadata
        (*CouplesAnalysisResults)(nil),    // 4: pb.CouplesAnalysisResults
        (*DeveloperStat)(nil),             // 5: pb.DeveloperStat
        (*LanguageStat)(nil),              // 6: pb.LanguageStat
        (*AnalysisResults)(nil),           // 7: pb.AnalysisResults
        nil,                               // 8: pb.FilesOwnership.ValueEntry
        nil,                               // 9: pb.DeveloperStat.LanguagesEntry
}
var file_pb_proto_depIdxs = []int32{
        1,  // 0: pb.BurndownAnalysisResults.project:type_name -&gt; pb.CompressedSparseRowMatrix
        1,  // 1: pb.BurndownAnalysisResults.files:type_name -&gt; pb.CompressedSparseRowMatrix
        1,  // 2: pb.BurndownAnalysisResults.people:type_name -&gt; pb.CompressedSparseRowMatrix
        1,  // 3: pb.BurndownAnalysisResults.people_interaction:type_name -&gt; pb.CompressedSparseRowMatrix
        2,  // 4: pb.BurndownAnalysisResults.files_ownership:type_name -&gt; pb.FilesOwnership
        8,  // 5: pb.FilesOwnership.value:type_name -&gt; pb.FilesOwnership.ValueEntry
        1,  // 6: pb.CouplesAnalysisResults.file_couples:type_name -&gt; pb.CompressedSparseRowMatrix
        9,  // 7: pb.DeveloperStat.languages:type_name -&gt; pb.DeveloperStat.LanguagesEntry
        3,  // 8: pb.AnalysisResults.metadata:type_name -&gt; pb.Metadata
        0,  // 9: pb.AnalysisResults.burndown:type_name -&gt; pb.BurndownAnalysisResults
        4,  // 10: pb.AnalysisResults.couples:type_name -&gt; pb.CouplesAnalysisResults
        5,  // 11: pb.AnalysisResults.developer_stats:type_name -&gt; pb.DeveloperStat
        6,  // 12: pb.AnalysisResults.language_stats:type_name -&gt; pb.LanguageStat
        13, // [13:13] is the sub-list for method output_type
        13, // [13:13] is the sub-list for method input_type
        13, // [13:13] is the sub-list for extension type_name
        13, // [13:13] is the sub-list for extension extendee
        0,  // [0:13] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_pb_proto_init() }</span>
func file_pb_proto_init() <span class="cov0" title="0">{
        if File_pb_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: unsafe.Slice(unsafe.StringData(file_pb_proto_rawDesc), len(file_pb_proto_rawDesc)),
                        NumEnums:      0,
                        NumMessages:   10,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_pb_proto_goTypes,
                DependencyIndexes: file_pb_proto_depIdxs,
                MessageInfos:      file_pb_proto_msgTypes,
        }.Build()
        File_pb_proto = out.File
        file_pb_proto_goTypes = nil
        file_pb_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package readers

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "strings"
)

// DetectAndReadInput detects the format (if "auto"), creates the appropriate Reader, and reads the input.
func DetectAndReadInput(input string, format string) (Reader, error) <span class="cov0" title="0">{
        // Open input source
        var file io.Reader
        if input == "-" </span><span class="cov0" title="0">{
                file = os.Stdin
        }</span> else<span class="cov0" title="0"> {
                f, err := os.Open(input)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error opening file %s: %v", input, err)
                }</span>
                <span class="cov0" title="0">defer f.Close()
                file = f</span>
        }

        // Detect format if set to "auto"
        <span class="cov0" title="0">if format == "auto" </span><span class="cov0" title="0">{
                var err error
                format, file, err = detectFormat(file)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Create the appropriate Reader
        <span class="cov0" title="0">reader, err := createReader(format)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Read the input using the Reader
        <span class="cov0" title="0">if err := reader.Read(file); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading input with %s reader: %v", format, err)
        }</span>

        <span class="cov0" title="0">return reader, nil</span>
}

// detectFormat inspects the input to determine the format (YAML or Protobuf).
func detectFormat(file io.Reader) (string, io.Reader, error) <span class="cov0" title="0">{
        buffer := make([]byte, 16)
        _, err := file.Read(buffer)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return "", nil, fmt.Errorf("error reading input for format detection: %v", err)
        }</span>

        // Rewind the file for further reading
        <span class="cov0" title="0">file = io.MultiReader(bytes.NewReader(buffer), file)

        if isYAML(buffer) </span><span class="cov0" title="0">{
                return "yaml", file, nil
        }</span>
        <span class="cov0" title="0">return "pb", file, nil</span>
}

// isYAML checks if the buffer contains YAML-specific patterns.
func isYAML(buffer []byte) bool <span class="cov0" title="0">{
        return bytes.Contains(buffer, []byte("hercules"))
}</span>

// createReader initializes the correct Reader implementation.
func createReader(format string) (Reader, error) <span class="cov0" title="0">{
        switch strings.ToLower(format) </span>{
        case "yaml":<span class="cov0" title="0">
                return &amp;YamlReader{}, nil</span>
        case "pb":<span class="cov0" title="0">
                return &amp;ProtobufReader{}, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported format: %s", format)</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package readers

import (
        "fmt"
        "io"

        "labours-go/internal/pb"

        "google.golang.org/protobuf/proto"
)

type ProtobufReader struct {
        data *pb.AnalysisResults
}

// Read loads the Protobuf data into the ProtobufReader structure
func (r *ProtobufReader) Read(file io.Reader) error <span class="cov7" title="7">{
        allBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading Protobuf file: %v", err)
        }</span>

        <span class="cov7" title="7">var results pb.AnalysisResults
        if err := proto.Unmarshal(allBytes, &amp;results); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("error unmarshalling Protobuf: %v", err)
        }</span>

        <span class="cov6" title="6">r.data = &amp;results
        return nil</span>
}

// GetName retrieves the repository name from the Protobuf metadata
func (r *ProtobufReader) GetName() string <span class="cov3" title="2">{
        if r.data.Metadata != nil </span><span class="cov3" title="2">{
                return r.data.Metadata.Repository
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetHeader retrieves the start and end timestamps from the Protobuf metadata
func (r *ProtobufReader) GetHeader() (int64, int64) <span class="cov1" title="1">{
        if r.data.Metadata != nil </span><span class="cov1" title="1">{
                return r.data.Metadata.BeginUnixTime, r.data.Metadata.EndUnixTime
        }</span>
        <span class="cov0" title="0">return 0, 0</span>
}

// GetProjectBurndown retrieves the project-level burndown matrix
func (r *ProtobufReader) GetProjectBurndown() (string, [][]int) <span class="cov1" title="1">{
        if r.data.Burndown == nil || r.data.Burndown.Project == nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov1" title="1">matrix := parseCompressedSparseRowMatrix(r.data.Burndown.Project)
        return r.GetName(), matrix</span>
}

// GetFilesBurndown retrieves burndown data for files
func (r *ProtobufReader) GetFilesBurndown() ([]FileBurndown, error) <span class="cov1" title="1">{
        if r.data.Burndown == nil || r.data.Burndown.Files == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no files burndown data found")
        }</span>

        <span class="cov1" title="1">matrix := parseCompressedSparseRowMatrix(r.data.Burndown.Files)
        
        // Create individual file burndown entries
        var fileBurndowns []FileBurndown
        for i, filename := range r.data.FileNames </span><span class="cov0" title="0">{
                if i &lt; len(matrix) </span><span class="cov0" title="0">{
                        fileBurndowns = append(fileBurndowns, FileBurndown{
                                Filename: filename,
                                Matrix:   [][]int{matrix[i]}, // Each row represents one file
                        })
                }</span>
        }
        <span class="cov1" title="1">return fileBurndowns, nil</span>
}

// GetPeopleBurndown retrieves burndown data for people
func (r *ProtobufReader) GetPeopleBurndown() ([]PeopleBurndown, error) <span class="cov1" title="1">{
        if r.data.Burndown == nil || r.data.Burndown.People == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no people burndown data found")
        }</span>

        <span class="cov1" title="1">matrix := parseCompressedSparseRowMatrix(r.data.Burndown.People)
        
        // Create individual people burndown entries
        var peopleBurndowns []PeopleBurndown
        for i, personName := range r.data.PeopleNames </span><span class="cov0" title="0">{
                if i &lt; len(matrix) </span><span class="cov0" title="0">{
                        peopleBurndowns = append(peopleBurndowns, PeopleBurndown{
                                Person: personName,
                                Matrix: [][]int{matrix[i]}, // Each row represents one person
                        })
                }</span>
        }
        <span class="cov1" title="1">return peopleBurndowns, nil</span>
}

// GetOwnershipBurndown retrieves the ownership matrix and sequence
func (r *ProtobufReader) GetOwnershipBurndown() ([]string, map[string][][]int, error) <span class="cov1" title="1">{
        if r.data.Burndown == nil || r.data.Burndown.FilesOwnership == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("no ownership data found")
        }</span>

        <span class="cov1" title="1">peopleSequence := r.data.PeopleNames
        ownership := make(map[string][][]int)

        // Use the files ownership mapping to create ownership matrices
        for filename, ownerIndex := range r.data.Burndown.FilesOwnership.Value </span><span class="cov3" title="2">{
                if int(ownerIndex) &lt; len(peopleSequence) </span><span class="cov0" title="0">{
                        ownerName := peopleSequence[ownerIndex]
                        if _, exists := ownership[ownerName]; !exists </span><span class="cov0" title="0">{
                                ownership[ownerName] = [][]int{}
                        }</span>
                        // For simplicity, create a basic matrix - this would need actual data
                        <span class="cov0" title="0">ownership[ownerName] = append(ownership[ownerName], []int{1})</span> // Placeholder
                }
                <span class="cov3" title="2">_ = filename</span> // Avoid unused variable warning
        }

        <span class="cov1" title="1">return peopleSequence, ownership, nil</span>
}

// GetPeopleInteraction retrieves the interaction matrix for people
func (r *ProtobufReader) GetPeopleInteraction() ([]string, [][]int, error) <span class="cov0" title="0">{
        if r.data.Burndown == nil || r.data.Burndown.PeopleInteraction == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("no people interaction data found")
        }</span>

        <span class="cov0" title="0">matrix := parseCompressedSparseRowMatrix(r.data.Burndown.PeopleInteraction)
        return r.data.PeopleNames, matrix, nil</span>
}

// GetFileCooccurrence retrieves file coupling data
func (r *ProtobufReader) GetFileCooccurrence() ([]string, [][]int, error) <span class="cov0" title="0">{
        if r.data.Couples == nil || r.data.Couples.FileCouples == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("no file coupling data found")
        }</span>

        <span class="cov0" title="0">matrix := parseCompressedSparseRowMatrix(r.data.Couples.FileCouples)
        return r.data.Couples.FileNames, matrix, nil</span>
}

// GetPeopleCooccurrence retrieves people coupling data
func (r *ProtobufReader) GetPeopleCooccurrence() ([]string, [][]int, error) <span class="cov0" title="0">{
        if r.data.Couples == nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("no people coupling data found")
        }</span>

        // For people coupling, we would need additional matrix data in the protobuf
        // For now, return empty data
        <span class="cov0" title="0">return r.data.PeopleNames, [][]int{}, nil</span>
}

// GetShotnessCooccurrence retrieves shotness coupling data
func (r *ProtobufReader) GetShotnessCooccurrence() ([]string, [][]int, error) <span class="cov0" title="0">{
        // This would require additional protobuf structure for shotness data
        return []string{}, [][]int{}, fmt.Errorf("shotness data not implemented in current protobuf format")
}</span>

// GetShotnessStats retrieves shotness statistics
func (r *ProtobufReader) GetShotnessStats() ([][]int, error) <span class="cov0" title="0">{
        // This would require additional protobuf structure for shotness data
        return [][]int{}, fmt.Errorf("shotness stats not implemented in current protobuf format")
}</span>

// GetDeveloperStats retrieves developer statistics
func (r *ProtobufReader) GetDeveloperStats() ([]DeveloperStat, error) <span class="cov0" title="0">{
        if len(r.data.DeveloperStats) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no developer stats found")
        }</span>

        <span class="cov0" title="0">stats := make([]DeveloperStat, len(r.data.DeveloperStats))
        for i, dev := range r.data.DeveloperStats </span><span class="cov0" title="0">{
                stats[i] = DeveloperStat{
                        Name:          dev.Name,
                        Commits:       int(dev.Commits),
                        LinesAdded:    int(dev.LinesAdded),
                        LinesRemoved:  int(dev.LinesRemoved),
                        LinesModified: int(dev.LinesModified),
                        FilesTouched:  int(dev.FilesTouched),
                        Languages:     make(map[string]int),
                }
                // Copy language map
                for lang, count := range dev.Languages </span><span class="cov0" title="0">{
                        stats[i].Languages[lang] = int(count)
                }</span>
        }

        <span class="cov0" title="0">return stats, nil</span>
}

// GetLanguageStats retrieves language statistics
func (r *ProtobufReader) GetLanguageStats() ([]LanguageStat, error) <span class="cov0" title="0">{
        if len(r.data.LanguageStats) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no language stats found")
        }</span>

        <span class="cov0" title="0">stats := make([]LanguageStat, len(r.data.LanguageStats))
        for i, lang := range r.data.LanguageStats </span><span class="cov0" title="0">{
                stats[i] = LanguageStat{
                        Language: lang.Language,
                        Lines:    int(lang.Lines),
                }
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// GetRuntimeStats retrieves runtime statistics
func (r *ProtobufReader) GetRuntimeStats() (map[string]float64, error) <span class="cov0" title="0">{
        if r.data.Metadata == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no metadata found for runtime stats")
        }</span>

        <span class="cov0" title="0">return map[string]float64{
                "total_runtime": float64(r.data.Metadata.RunTime),
        }, nil</span>
}

// parseCompressedSparseRowMatrix converts protobuf CompressedSparseRowMatrix to dense matrix
func parseCompressedSparseRowMatrix(matrix *pb.CompressedSparseRowMatrix) [][]int <span class="cov4" title="3">{
        if matrix == nil </span><span class="cov0" title="0">{
                return [][]int{}
        }</span>

        <span class="cov4" title="3">result := make([][]int, matrix.NumberOfRows)
        for i := range result </span><span class="cov6" title="5">{
                result[i] = make([]int, matrix.NumberOfColumns)
        }</span>

        // Convert from CSR format to dense matrix
        <span class="cov4" title="3">for i := int32(0); i &lt; matrix.NumberOfRows; i++ </span><span class="cov6" title="5">{
                start := matrix.Indptr[i]
                end := matrix.Indptr[i+1]
                
                for j := start; j &lt; end; j++ </span><span class="cov10" title="15">{
                        col := matrix.Indices[j]
                        value := matrix.Data[j]
                        result[i][col] = int(value)
                }</span>
        }

        <span class="cov4" title="3">return result</span>
}</pre>
		
		<pre class="file" id="file15" style="display: none">package readers

import (
        "fmt"
        "io"
        "strconv"
        "strings"

        "gopkg.in/yaml.v3"
)

type YamlReader struct {
        data map[string]interface{}
}

func (r *YamlReader) Read(file io.Reader) error <span class="cov0" title="0">{
        decoder := yaml.NewDecoder(file)
        if err := decoder.Decode(&amp;r.data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error decoding YAML: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *YamlReader) GetName() string <span class="cov0" title="0">{
        herculesData, ok := r.data["hercules"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return herculesData["repository"].(string)</span>
}

func (r *YamlReader) GetHeader() (int64, int64) <span class="cov0" title="0">{
        herculesData, ok := r.data["hercules"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return 0, 0
        }</span>
        <span class="cov0" title="0">begin := int64(herculesData["begin_unix_time"].(int))
        end := int64(herculesData["end_unix_time"].(int))
        return begin, end</span>
}

func (r *YamlReader) GetProjectBurndown() (string, [][]int) <span class="cov0" title="0">{
        burndownData, ok := r.data["Burndown"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">repo := r.GetName()
        matrix := parseBurndownMatrix(burndownData["project"].(string))
        return repo, matrix</span>
}

func (r *YamlReader) GetFilesBurndown() ([]FileBurndown, error) <span class="cov0" title="0">{
        burndownData, ok := r.data["Burndown"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing Burndown data in YAML")
        }</span>
        <span class="cov0" title="0">filesData, ok := burndownData["files"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing files data in Burndown")
        }</span>

        <span class="cov0" title="0">var fileBurndowns []FileBurndown
        for filename, matrixData := range filesData </span><span class="cov0" title="0">{
                matrix := parseBurndownMatrix(matrixData.(string))
                fileBurndowns = append(fileBurndowns, FileBurndown{
                        Filename: filename,
                        Matrix:   matrix,
                })
        }</span>
        <span class="cov0" title="0">return fileBurndowns, nil</span>
}

func (r *YamlReader) GetPeopleBurndown() ([]PeopleBurndown, error) <span class="cov0" title="0">{
        burndownData, ok := r.data["Burndown"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing Burndown data in YAML")
        }</span>
        <span class="cov0" title="0">peopleData, ok := burndownData["people"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing people data in Burndown")
        }</span>

        <span class="cov0" title="0">var peopleBurndowns []PeopleBurndown
        for person, matrixData := range peopleData </span><span class="cov0" title="0">{
                matrix := parseBurndownMatrix(matrixData.(string))
                peopleBurndowns = append(peopleBurndowns, PeopleBurndown{
                        Person: person,
                        Matrix: matrix,
                })
        }</span>
        <span class="cov0" title="0">return peopleBurndowns, nil</span>
}

func (r *YamlReader) GetOwnershipBurndown() ([]string, map[string][][]int, error) <span class="cov0" title="0">{
        burndownData, ok := r.data["Burndown"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing Burndown data in YAML")
        }</span>
        <span class="cov0" title="0">peopleSequence, ok := burndownData["people_sequence"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing people_sequence in Burndown")
        }</span>

        <span class="cov0" title="0">peopleData, ok := burndownData["people"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing people data in Burndown")
        }</span>

        <span class="cov0" title="0">ownership := make(map[string][][]int)
        for person, matrixData := range peopleData </span><span class="cov0" title="0">{
                matrix := parseBurndownMatrix(matrixData.(string))
                ownership[person] = matrix
        }</span>

        <span class="cov0" title="0">return peopleSequence, ownership, nil</span>
}

func (r *YamlReader) GetPeopleInteraction() ([]string, [][]int, error) <span class="cov0" title="0">{
        burndownData, ok := r.data["Burndown"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing Burndown data in YAML")
        }</span>
        <span class="cov0" title="0">peopleSequence, ok := burndownData["people_sequence"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing people_sequence in Burndown")
        }</span>
        <span class="cov0" title="0">interactionData, ok := burndownData["people_interaction"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing people_interaction data")
        }</span>

        <span class="cov0" title="0">matrix := parseBurndownMatrix(interactionData)
        return peopleSequence, matrix, nil</span>
}

func (r *YamlReader) GetFileCooccurrence() ([]string, [][]int, error) <span class="cov0" title="0">{
        couplesData, ok := r.data["Couples"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing Couples data in YAML")
        }</span>
        <span class="cov0" title="0">fileIndex, ok := couplesData["file_couples_index"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing file_couples_index in Couples")
        }</span>
        <span class="cov0" title="0">matrixData, ok := couplesData["file_couples_matrix"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing file_couples_matrix in Couples")
        }</span>

        <span class="cov0" title="0">matrix := parseBurndownMatrix(matrixData)
        return fileIndex, matrix, nil</span>
}

func (r *YamlReader) GetPeopleCooccurrence() ([]string, [][]int, error) <span class="cov0" title="0">{
        couplesData, ok := r.data["Couples"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing Couples data in YAML")
        }</span>
        <span class="cov0" title="0">peopleIndex, ok := couplesData["people_couples_index"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing people_couples_index in Couples")
        }</span>
        <span class="cov0" title="0">matrixData, ok := couplesData["people_couples_matrix"].(string)
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing people_couples_matrix in Couples")
        }</span>

        <span class="cov0" title="0">matrix := parseBurndownMatrix(matrixData)
        return peopleIndex, matrix, nil</span>
}

func (r *YamlReader) GetShotnessCooccurrence() ([]string, [][]int, error) <span class="cov0" title="0">{
        shotnessData, ok := r.data["Shotness"].([]map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("missing Shotness data in YAML")
        }</span>

        <span class="cov0" title="0">var names []string
        var matrix [][]int
        for _, record := range shotnessData </span><span class="cov0" title="0">{
                name := fmt.Sprintf("%s:%s:%s", record["type"], record["name"], record["file"])
                names = append(names, name)
                row := make([]int, len(record["counters"].(map[string]int)))
                for _, value := range record["counters"].(map[string]int) </span><span class="cov0" title="0">{
                        row = append(row, value)
                }</span>
                <span class="cov0" title="0">matrix = append(matrix, row)</span>
        }
        <span class="cov0" title="0">return names, matrix, nil</span>
}

func (r *YamlReader) GetShotnessStats() ([][]int, error) <span class="cov0" title="0">{
        shotnessData, ok := r.data["Shotness"].([]map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing Shotness data in YAML")
        }</span>

        <span class="cov0" title="0">var stats [][]int
        for _, record := range shotnessData </span><span class="cov0" title="0">{
                row := make([]int, len(record["counters"].(map[string]int)))
                for _, value := range record["counters"].(map[string]int) </span><span class="cov0" title="0">{
                        row = append(row, value)
                }</span>
                <span class="cov0" title="0">stats = append(stats, row)</span>
        }
        <span class="cov0" title="0">return stats, nil</span>
}

func (r *YamlReader) GetDeveloperStats() ([]DeveloperStat, error) <span class="cov0" title="0">{
        devsData, ok := r.data["Devs"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing Devs data in YAML")
        }</span>
        <span class="cov0" title="0">devIndex, ok := devsData["dev_index"].([]string)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing dev_index in Devs")
        }</span>
        <span class="cov0" title="0">ticks, ok := devsData["ticks"].(map[string]interface{})
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("missing ticks in Devs")
        }</span>

        <span class="cov0" title="0">var devStats []DeveloperStat
        for _, tick := range ticks </span><span class="cov0" title="0">{
                // Assert the tick as a map
                tickMap, ok := tick.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid tick format")
                }</span>

                // Get the "devs" map from the tick
                <span class="cov0" title="0">devs, ok := tickMap["devs"].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("missing 'devs' in tick")
                }</span>

                // Iterate over devs map
                <span class="cov0" title="0">for id, stats := range devs </span><span class="cov0" title="0">{
                        // Cast stats to a map
                        statsMap, ok := stats.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid stats format for developer %s", id)
                        }</span>

                        // Parse developer stats
                        <span class="cov0" title="0">commits, _ := statsMap["commits"].(int)       // Safely cast commits
                        linesAdded, _ := statsMap["added"].(int)      // Safely cast linesAdded
                        linesRemoved, _ := statsMap["removed"].(int)  // Safely cast linesRemoved
                        linesModified, _ := statsMap["changed"].(int) // Safely cast linesModified

                        index, err := strconv.Atoi(id)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid developer index: %v", err)
                        }</span>

                        // Append developer stats
                        <span class="cov0" title="0">devStats = append(devStats, DeveloperStat{
                                Name:          devIndex[index],
                                Commits:       commits,
                                LinesAdded:    linesAdded,
                                LinesRemoved:  linesRemoved,
                                LinesModified: linesModified,
                        })</span>
                }
        }

        <span class="cov0" title="0">return devStats, nil</span>
}

func (r *YamlReader) GetLanguageStats() ([]LanguageStat, error) <span class="cov0" title="0">{
        // Stub: Language stats data is typically not present in YAML files.
        return nil, fmt.Errorf("language stats not implemented for YAML")
}</span>

func (r *YamlReader) GetRuntimeStats() (map[string]float64, error) <span class="cov0" title="0">{
        // Stub: Runtime stats are typically not present in YAML files.
        return nil, fmt.Errorf("runtime stats not implemented for YAML")
}</span>

// Helper function to parse burndown matrices
func parseBurndownMatrix(data string) [][]int <span class="cov0" title="0">{
        lines := strings.Split(data, "\n")
        var matrix [][]int
        for _, line := range lines </span><span class="cov0" title="0">{
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">numbers := strings.Fields(line)
                var row []int
                for _, num := range numbers </span><span class="cov0" title="0">{
                        val, err := strconv.Atoi(num)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">row = append(row, val)</span>
                }
                <span class="cov0" title="0">matrix = append(matrix, row)</span>
        }
        <span class="cov0" title="0">return matrix</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
